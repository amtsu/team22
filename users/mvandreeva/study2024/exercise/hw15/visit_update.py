import csv

class VisitUpdate:
    """
    Класс для чтения файла visits_status.csv как csv-формат.
    Имеет возможность редактировать значение статуса для определенной даты.
    Имеет возможность сохранения валидного для github csv-формата - 
		* разделители - запятые (,)
		* количество "колонок" одинаково для всех "строчек"
    """

    """
    Открываем файл
    Считываем первую строку файла
    Сверяем, есть ли в этой строке логин пользователя
    если есть, то записываем строку в переменную, записываем номер строки
    если нет, то считываем следующую строку, пока не найдем строку с логином.
    если логин не найден, а строки закончились, выводим сообщение, что данного пользователя нет в списке.

    считываем первую строку файла (заголовки).
    находим заголовок для исправления (дата или номер дз), соответствующий вводу пользователя.
    определяем позицию данной записи в строке
    заменяем значение в пользовательской строке в данной позиции на пользовательский ввод.
    сохраняем новое значения пользовательской строки
    Сохраняем изменение в файл.

    Распечатывание информации: печать строки заголовков, печать строки пользователя
    
    """

    def __init__(self, file_to_edit, user_login): #file_to_edit должен содержать относительный путь от папки team22, включать название файла, в формате str
        if isinstance(user_login, str) and isinstance(file_to_edit, str):
            self.__login = user_login 
            self.__file = f"/home/jupyter-{self.__login.lower()}/github/team22/{file_to_edit}"
        self.__user_row_num = 0 #номер ряда с логином пользователя
        self.__full_data = [] #полный список данных из файла
        self.__user_data = '' #строка данных пользователя
        self.__headers = '' #строка заголовков файла
        self.__read_csv()

    def __read_csv(self):
        """Метод читает файл csv"""
        # self.__user_row_num = 0
        with open(self.__file, 'r') as csv_file: #Открываем файл
            csv_reader = csv.reader(csv_file)
            self.__headers = csv_reader[0]
            for row in csv_reader:    #Считываем строки файла
                self.__full_data.append(row)
                self.__user_row_num += 1 # записываем номер строки
                if row[0] == self.__login: #cверяем, есть ли в этой строке логин пользователя
                    self.__user_data = row #если есть, то записываем строку в переменную
            if not self.__user_data: #если логин не найден, а строки закончились, выводим сообщение, что данного пользователя нет в списке
                print(f"Пользователя с логином {self.__login} нет в списке")

    def update_user_status(self, **kvargs):
        """Метод редактирует данные пользователя, в соответствии с пользовательским вводом"""
        for k, v in kvargs: # для каждого переданного значения ищем совпадения с заголовками и заменяем значение в соответстыующем столбце
            for i in range(len(self.__headers)):
                if k in self.__headers[i]: #находим заголовок для исправления (дата или номер дз), соответствующий вводу пользователя, определяем позицию данной записи в строке
                    self.__user_data[i] = v #заменяем значение в пользовательской строке в данной позиции на пользовательский ввод
                else: 
                    print(f"Значение {k} не найдено")
        self.__full_data[self.__user_row_num] = self.__user_data # записываем изменения строки пользователя в общий список
        self.__save() #Сохраняем изменение в файл.
                
    def __save(self):
        with open(self.__file, 'w') as csv_file:
            csv_writer = csv.writer(csv_file)
            for row in self.__full_data:
                csv_writer.writerow(row)

    def __str__(self):
        return f"{self.__full_data}"

    def user_info(self):
        print(self.__headers)
        print(self.__user_data)













